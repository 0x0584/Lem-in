* hash string using direct summation

+ If the hash table size M is small compared to the resulting summations,
  then this hash function should do a good job of distributing strings
  evenly among the hash table slots.

  because it gives *equal weight to all characters in the string*.

+ the order of the characters in the string has no effect on the result

  because it's a summation with equal weight so 'A' + 'Z' = 'Z' + 'A'

+ sum will always be in the range 650 to 900 for a string of
  ten upper case letters

+ For a hash table of size 100 or less, a reasonable distribution results

+ For a hash table of size 1000, the distribution is not reasonable
  since the values are not evenly distributed even within those slots

* hash string using folding

 #+BEGIN_SRC c
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>

   size_t compute_hash(char *s, size_t size, size_t sum) {
       for (size_t i = 0; i < size; ++i)
           for (size_t mul = 1, j = 0, k = i + 16; j < k; ++j, mul <<= 9u)
               sum += s[i] * mul;
       return sum;
   }

   size_t sfold(char *s, size_t mod) {
       size_t size = strlen(s);
       return compute_hash(s, size / 4, compute_hash(s, size, 0)) % mod;
   }

   int main(int argc, char *argv[]) {
       (void)argc;
       if (argc == 2)
           printf("%s #%zu", argv[1], sfold(argv[1], atoll(argv[2])));
       return 0;
   }
 #+END_SRC
